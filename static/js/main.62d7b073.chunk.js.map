{"version":3,"sources":["Components/App/App.module.css","Components/Card/Card.module.css","Components/Card/Card.js","assets/title3.png","assets/background.jpeg","Components/App/App.js","Components/Search/useCardSearch.js","assets/searchIcon.png","reportWebVitals.js","reducers/rootReducer.js","index.js"],"names":["module","exports","Card","props","className","styles","src","imgURL","alt","name","type","set","text","id","App","useState","query","setQuery","pageNumber","setPageNumber","loading","setLoading","error","setError","cards","setCards","hasMore","setHasMore","useEffect","cancel","axios","method","url","params","page","cancelToken","CancelToken","c","then","res","prevCards","Set","data","map","card","imageUrl","length","catch","e","isCancel","useCardSearch","observer","useRef","lastCardElementRef","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","prevPageNumber","observe","title","value","onChange","target","placeholder","index","ref","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","initState","post","rootReducer","state","store","createStore","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.62d7b073.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"backgroundImg\":\"App_backgroundImg__3T8O9\",\"bodyContainer\":\"App_bodyContainer__2BdQZ\",\"searchInput\":\"App_searchInput__2oMD_\",\"searchInputContainer\":\"App_searchInputContainer__1Ov39\",\"searchIcon\":\"App_searchIcon__XY7Tn\",\"card\":\"App_card__2Bem6\",\"cardContainer\":\"App_cardContainer__2dCBN\",\"loadingSpinner\":\"App_loadingSpinner__16yk0\",\"pulsing\":\"App_pulsing__uCnwQ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"html\":\"Card_html__1nREt\",\"cardContainer\":\"Card_cardContainer__WcW_e\",\"overlay\":\"Card_overlay__2Iwmd\",\"infoContainer\":\"Card_infoContainer__3moef\",\"cardImg\":\"Card_cardImg__12CFR\"};","import React from 'react';\nimport * as styles from './Card.module.css';\nfunction Card(props) {\n\treturn (\n\t\t<div className={styles.cardContainer} key={props.id}>\n\t\t\t<div className={styles.overlay}>\n\t\t\t\t<img src={props.imgURL} alt=\"elder scroll legend ...\" className={styles.cardImg} />\n\t\t\t</div>\n\t\t\t<div className={styles.infoContainer}>\n\t\t\t\t<div className={styles.name}>\n\t\t\t\t\tName: <span>{props.name}</span>\n\t\t\t\t</div>\n\t\t\t\t<div className={styles.type}>\n\t\t\t\t\tType: <span>{props.type}</span>\n\t\t\t\t</div>\n\t\t\t\t<div className={styles.setName}>\n\t\t\t\t\tSet Name: <span>{props.set}</span>\n\t\t\t\t</div>\n\t\t\t\t<br />\n\t\t\t\t<div className={styles.text}>\n\t\t\t\t\t<span>{props.text}</span>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default Card;\n","export default __webpack_public_path__ + \"static/media/title3.3aca7ae5.png\";","export default __webpack_public_path__ + \"static/media/background.6515c696.jpeg\";","import React, { useState, useRef, useCallback } from 'react';\nimport './App.css';\nimport useCardSearch from '../Search/useCardSearch';\nimport Card from '../Card/Card';\nimport * as styles from './App.module.css';\nimport searchIcon from '../../assets/searchIcon.png';\nimport title from '../../assets/title3.png';\nimport background from '../../assets/background.jpeg';\nfunction App() {\n\tconst [ query, setQuery ] = useState('');\n\tconst [ pageNumber, setPageNumber ] = useState('');\n\n\tconst { cards, hasMore, loading, error } = useCardSearch(query, pageNumber);\n\n\t//this variable take on the value of the last card which will allow us to trigger infinite scrolling\n\tconst observer = useRef();\n\t//this will allow us to set the value of obeserver\n\tconst lastCardElementRef = useCallback(\n\t\t(node) => {\n\t\t\t//we just want to return if loading because we don't want to constantly trigger API calls while loading\n\t\t\tif (loading) return;\n\n\t\t\t//by disconnecting the current observer here we will be able to update the new last card for the next page to allow infinite scrolling\n\t\t\tif (observer.current) observer.current.disconnect();\n\t\t\t//this will set the new observer/new last card and when it is visible on the browser it will update the state and add one to the page number\n\t\t\t//also by checking against the hasMore we can prevent the calling of the API and prevent the browser to keep paginating when its no longer necessary\n\t\t\tobserver.current = new IntersectionObserver((entries) => {\n\t\t\t\tif (entries[0].isIntersecting && hasMore) {\n\t\t\t\t\tsetPageNumber((prevPageNumber) => prevPageNumber + 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\t//if there is a last card observer will be observing it\n\t\t\tif (node) observer.current.observe(node);\n\t\t},\n\t\t[ loading, hasMore ]\n\t);\n\n\t//handleSearch will allow for updating the search query by Name when user is searching in the input, and it will reset the page number back to one because when user re-query/new query we want data to restart at very first page\n\tfunction handleSearch(e) {\n\t\tsetQuery(e.target.value);\n\t\tsetPageNumber(1);\n\t}\n\treturn (\n\t\t<div className={styles.bodyContainer}>\n\t\t\t<div className={styles.title}>\n\t\t\t\t<img src={title} alt=\"Elder Scrolls Legends Title\" />\n\t\t\t</div>\n\t\t\t<div className={styles.backgroundImg} />\n\t\t\t<div className={styles.searchInputContainer}>\n\t\t\t\t<input\n\t\t\t\t\ttype=\"text\"\n\t\t\t\t\tvalue={query}\n\t\t\t\t\tonChange={handleSearch}\n\t\t\t\t\tplaceholder=\"Search...\"\n\t\t\t\t\tclassName={styles.searchInput}\n\t\t\t\t/>\n\t\t\t\t<img src={searchIcon} alt=\"search icon\" className={styles.searchIcon} />\n\t\t\t</div>\n\t\t\t<div>{loading && <div className={styles.loadingSpinner}>Loading...</div>}</div>\n\n\t\t\t<div className={styles.cardContainer}>\n\t\t\t\t<div className={styles.backgroundImg} />\n\n\t\t\t\t{cards.map((card, index) => {\n\t\t\t\t\t//this will map through our array of cards and display it individually in our card component\n\n\t\t\t\t\t//this if statement checks for the very last book, which will render more cards\n\t\t\t\t\tif (cards.length === index + 1) {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t//ref will allow us to get a piece of persisting information even after each rendering\n\t\t\t\t\t\t\t<div ref={lastCardElementRef} key={index} className={styles.card}>\n\t\t\t\t\t\t\t\t<Card name={card[0]} id={card[1]} set={card[2]} text={card[3]} imgURL={card[4]} />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t//essentially this returns the same thing but without the ref which isn't necessary anymore when there's no more data to load meaning no longer needs to check for observer\n\t\t\t\t\t\t\t<div key={index} className={styles.card}>\n\t\t\t\t\t\t\t\t<Card\n\t\t\t\t\t\t\t\t\tname={card[0]}\n\t\t\t\t\t\t\t\t\tid={card[1]}\n\t\t\t\t\t\t\t\t\tset={card[2]}\n\t\t\t\t\t\t\t\t\ttext={card[3]}\n\t\t\t\t\t\t\t\t\timgURL={card[4]}\n\t\t\t\t\t\t\t\t\ttype={card[5]}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t})}\n\n\t\t\t\t<div>{error && 'ERROR... Something has gone wrong'}</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\n//this functional component will be the logic for fetching/querying API and handling infinite scrolling\n\nexport default function useCardSearch(query, pageNumber) {\n\t// allow to control when to show loading spinner\n\tconst [ loading, setLoading ] = useState(true);\n\t// shows error message when error occur i.e API not fetching\n\tconst [ error, setError ] = useState(false);\n\t// stores the cards fetch from API\n\tconst [ cards, setCards ] = useState([]);\n\t// allows to checks if there is a need to fetch/load more cards from API when checking against the number of results found when querying\n\t//this will also prevent from making request to API when there aren't any more results needed to be loaded/fetched\n\tconst [ hasMore, setHasMore ] = useState(false);\n\n\t//checks when new query made and resets the cards in state, so old results aren't loaded with new search results\n\tuseEffect(\n\t\t() => {\n\t\t\tsetCards([]);\n\t\t},\n\t\t[ query ]\n\t);\n\n\tuseEffect(\n\t\t() => {\n\t\t\t//initally set loading to true because thats when loading fetch results from API\n\t\t\tsetLoading(true);\n\t\t\t//initially there won't be any error which hopefully succeed and when failed it'll caught in the .catch() method\n\t\t\tsetError(false);\n\n\t\t\t//cancel variable will allow for canceling request since we don't want to request past queries from user input just the current\n\t\t\t//this variable will get its value from the provided axios cancelToken\n\t\t\tlet cancel;\n\n\t\t\t// allows to fetch API asynchronously\n\t\t\t// axios provides parameters for get method as well as being able to customize what parameters you may want to add in order to query the info you want from API\n\t\t\t// cancel token will cancel old queries when typing new inputs to search input\n\t\t\taxios({\n\t\t\t\tmethod      : 'GET',\n\t\t\t\turl         : 'https://api.elderscrollslegends.io/v1/cards?pageSize=20',\n\t\t\t\tparams      : { name: query, page: pageNumber },\n\t\t\t\tcancelToken : new axios.CancelToken((c) => (cancel = c))\n\t\t\t})\n\t\t\t\t//this data recieved from the API will be stored in the state where we will be access the following info and display in individual cards\n\t\t\t\t.then((res) => {\n\t\t\t\t\t//below are the information we will be storing to the state from API\n\t\t\t\t\t//if needed we can add more properties below from API, and display it by passing its index value\n\t\t\t\t\t//this will allow us to perform infinite scrolling as well by updating the previous cards with the new cards that loads when scrolling down to the bottom and needs to append more cards if there are more\n\t\t\t\t\tsetCards((prevCards) => {\n\t\t\t\t\t\t//by passing our array of cards into Set we will get a return of unique values and then we are returning all of the unique results of combine old and new cards in an array, which will allow us to do all of the normal array manipulation such as mapping them to individual cards\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\t...new Set([\n\t\t\t\t\t\t\t\t...prevCards,\n\t\t\t\t\t\t\t\t...res.data.cards.map((card) => [\n\t\t\t\t\t\t\t\t\tcard.name,\n\t\t\t\t\t\t\t\t\tcard.id,\n\t\t\t\t\t\t\t\t\tcard.set.name,\n\t\t\t\t\t\t\t\t\tcard.text,\n\t\t\t\t\t\t\t\t\tcard.imageUrl,\n\t\t\t\t\t\t\t\t\tcard.type\n\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t])\n\t\t\t\t\t\t];\n\t\t\t\t\t});\n\t\t\t\t\t//checks if we need to load more cards by checking if the length is >0, which essentially means no more data since there are no cards returned to client\n\t\t\t\t\t//since no more data needs to be loaded we can also set loading to false\n\t\t\t\t\tsetHasMore(res.data.cards.length > 0);\n\t\t\t\t\tsetLoading(false);\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\t//this will check if fetch request is canceled with axios built in method.\n\t\t\t\t\t//If this was an axios request cancelation than the error will be ignored and will not be shown\n\t\t\t\t\tif (axios.isCancel(e)) return;\n\t\t\t\t\t// we want to set to true here because this is where error would be caught and we want to display error to users when there are issues\n\t\t\t\t\tsetError(true);\n\t\t\t\t});\n\t\t\t//this cancel() function will now cancel the old query everytime the useEffect is called\n\t\t\treturn () => cancel();\n\t\t},\n\t\t// runs the querying everytime we have a change in the query made and change in page numbers\n\t\t[ query, pageNumber ]\n\t);\n\t//this will allow us to get information from our state from this functional component\n\treturn { loading, error, cards, hasMore };\n}\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAF5SURBVHgBrZRdTsJAEMdnRkRJfOAIReW9VyCiiacAT6A3EG8gJ7CcgEcTNOEI8q4k9QZ9IKnRdteZ2oXa0G35+Ceb7uxOf52dmS5CTuHkrI8EPZ66PJo8Ah4zAvDq3fkIKgiXsKnjUERjjeha/H19EHcaHd+HMqgAMaYpmw6UqxRMCfk/MNAaH/RP3DruzlGeYsNfGkQOxTQGW6RpDp8MMFLUObl6n+UdF5O2WyPFH0/yLNH0i3JMaVEScUTDdUCRrGuth8ZWDIUCyfFXhYkiD2yKVHbftUGbxmhc26ua22/aoKYAED47DlgkXZIxAxt0lcMa9cEiUtTLmLNCP61gWUFEvP3mKq9zXEzbLhfyLhONVwRNmv/r9fSNpwYWIOpHRWokDS4poTr1UqDJo8893LJC5UU8rPxH8YnAO7qY31ih+wZjfsF2S8UaW5ya+zIwwoYKX84HZeCNoVXAW0HLwFtDbWCCHdS4/Bikd20ipfAT9iWJWIaxfwGDZ6zGlCTtPAAAAABJRU5ErkJggg==\"","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","const initState = {\n\tpost : []\n};\nconst rootReducer = (state = initState, action) => {\n\treturn state;\n};\n\nexport default rootReducer;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './Components/App/App';\nimport reportWebVitals from './reportWebVitals';\nimport { createStore } from 'redux';\n\nimport { Provider } from 'react-redux';\nimport rootReducer from './reducers/rootReducer';\n\nconst store = createStore(rootReducer);\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<Provider store={store}>\n\t\t\t<App />\n\t\t</Provider>\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}